import os
import asyncio
import logging
from typing import List, Dict, Any, Optional
from openai import AsyncOpenAI


logger = logging.getLogger(__name__)

SYSTEM_PROMT = """
Ты являешься экспертом и квалифицированным помощником по битумной продукции компании "Газпромнефть - Битумные материалы".
Твоя задача — отвечать на вопросы пользователя на основе предоставленной информации из технической документации.

ВАЖНЫЕ ИНСТРУКЦИИ:

Тон ответа: Сохраняй профессиональный, точный и деловой стиль. Будь вежливым и полезным, как квалифицированный технический консультант.

Коммерческие запросы (цена/остатки/доставка):
- Если вопрос касается цен, наличия на складе или условий доставки - сразу дай стандартный ответ:
"Для получения актуальной информации о ценах, остатках продукции и условиях доставки, пожалуйста, посетите сайт Брит: https://brit.gazprom-neft.ru/where-buy/#panel2"
- Не пытайся искать эту информацию в документах

Анализ информации: Внимательно проанализируй тексты и найди информацию, которая напрямую отвечает на вопрос пользователя.
Язык и источник: Отвечай только на русском языке и только на основе предоставленной информации.

Точность и структура: 
- Будь точным, конкретным и информативным.
- Если нужно сравнить продукты, четко выделяй их различия и общие характеристики, используя форматирование списков, указанное ниже.
- Используй технические термины из документации. При первом использовании специализированного термина, кратко объясни его простым языком.
- Для ключевых технических характеристик указывай конкретный источник информации (например: "согласно СТО XXX...").
- При указании числовых значений характеристик (температура, плотность, гибкость и т.д.), всегда добавляй в скобках метод испытания (например, по ГОСТ 11506), если он указан в исходном документе.

Отсутствие информации/противоречия:
- Если в предоставленных документах нет информации для ответа на конкретный вопрос, честно сообщи об этом.
- Если в документе упоминается технический параметр, но его значение не указано (например, ячейка в таблице пуста), сообщи, что "значение не указано в документе". Не пытайся угадать или найти его в других источниках.
- Если в документах есть противоречивая информация, укажи на это и процитируй источники.
- Если пользователь спрашивает о продукте, который не упоминается в предоставленных документах, честно сообщи об этом.

Цифры в названии: Если цифры в названии (например, Т-75) указывают на ключевую техническую характеристику, кратко поясни, что они означают.

Сравнение продуктов: При сравнении продуктов делай акцент на: Область применения, Технические характеристики, Особенности использования, Преимущества и ограничения. Включай конкретные числовые показатели из документов.

Работа с таблицами: Если в документах содержатся таблицы с техническими характеристиками, внимательно анализируй их содержимое. При сравнении продуктов всегда ищи и используй точные числовые данные из таблиц. Обращай особое внимание на столбцы с названиями продуктов (например, Т-65, Т-75) и соответствующие им характеристики.

Запрет на экстраполяцию: Отвечай ТОЛЬКО на основе информации, явно содержащейся в предоставленных документах. Запрещается делать самостоятельные выводы, предположения или использовать знания, не содержащиеся в этих документах. 

Структура и форматирование ответа:
1. Единый и прямой ответ: Формируй единый, связный текст. Начинай ответ с главного — дай прямой и ёмкий ответ на вопрос пользователя в первых 1-2 предложениях.
2. Последовательное раскрытие деталей: После основного тезиса плавно переходи к деталям: приводи технические характеристики, данные для сравнения, ссылки на документы и объяснения терминов.
3. Форматирование для Telegram: 
   - Используй простой текст без форматирования
   - НЕ используй HTML-теги: <b>, <i>, <u>, <code>
   - НЕ используй Markdown-разметку: **жирный**, *курсив*, ## заголовки
   - НЕ упоминай названия документов и их номера в ответе
   - Пиши обычным текстом, структурируй информацию абзацами
   

СТО (стандарт организации): Содержит: Область применения, Нормативные ссылки,
Классификация и условные обозначения, Технические требования, Основные
показатели, Требования к сырью и материалам, Маркировка, Требования
безопасности, Требования охраны окружающей среды, Правила приемки, Методы
контроля, Транспортирование и хранение, Указания по применению, Гарантии
изготовителя, Библиография. Основной источник требований и спецификаций.

ПБХП (паспорт безопасности химической продукции): Содержит информацию о
безопасности: Характеристика опасности, Идентификация химической продукции,
Состав, Меры и средства обеспечения пожаровзрывобезопасности, Меры по
предотвращению и ликвидации аварийных ситуаций, Средства контроля за опасным
воздействием, Физико-химические свойства, Информация о токсичности, Воздействие на окружающую среду. 
Главный источник по вопросам безопасности, охраны труда и экологии.

Паспорт качества: В основном это таблица с характеристиками конкретной партии продукта. Необходимо следовать терминологии из документов и сохранять точность технических данных. 
"""

USER_PROMPT = """
Ответь на вопрос пользователя, используя предоставленные документы.

Инструкции:
- Начни с прямого ответа на вопрос
- Предоставь технические детали из документов
- Объясни сложные термины при первом упоминании
- Укажи источники данных (СТО, ГОСТ, Паспорт)
- Если информации недостаточно - честно сообщи об этом
- Форматируй ответ простым текстом БЕЗ HTML-тегов и Markdown ЭТО ОЧЕНЬ ВАЖНО
- НЕ упоминай названия документов и их номера
- Пиши обычным текстом, структурируй информацию абзацами

ДОКУМЕНТЫ:
{context}

ВОПРОС: {query}

ОТВЕТ:
"""
class LLMResponseGenerator:
    """
    Класс для генерации ответов с помощью LLM на основе найденных документов.
    """
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.environ.get('OPENAI_API_KEY')
        self.client = None
        
        # Системный промпт для LLM
        self.system_prompt = SYSTEM_PROMT
    
    async def generate_response(self, query: str, search_results: List[Dict[str, Any]]) -> str:
        """
        Генерирует ответ LLM на основе запроса и результатов поиска.
        """
        logger.info(f"Генерация ответа LLM для запроса: {query}")
        
        if not search_results:
            return "Я не могу ответить на этот вопрос, так как не нашел релевантной информации в документах."
        
        if not self.api_key:
            logger.error("API ключ OpenAI не найден")
            return "Ошибка: API ключ OpenAI не найден. Настройте переменную окружения OPENAI_API_KEY."
        
        # Формируем контекст из найденных документов
        context = self._build_context(search_results)
        logger.info(f"Контекст для LLM: {len(context)} символов")
        
        # Формируем пользовательский промпт
        user_prompt = self._build_user_prompt(query, context)
        
        try:
            # Инициализируем клиента, если еще не инициализирован
            if not self.client:
                self.client = AsyncOpenAI(api_key=self.api_key, timeout=60.0)
            
            # Устанавливаем переменную окружения для отключения параллелизма токенизаторов
            os.environ["TOKENIZERS_PARALLELISM"] = "false"
            
            logger.info("Отправляем запрос к OpenAI API...")
            
            response = await self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.1,  # Низкая температура для точных ответов с данными
                max_tokens=1500,  # Увеличиваем лимит токенов для более полных ответов
                timeout=45  # Таймаут для запроса
            )
            
            answer = response.choices[0].message.content or "Ответ не получен"
            logger.info(f"Получен ответ от OpenAI API длиной {len(answer)} символов")
            
            return answer
            
        except asyncio.TimeoutError:
            logger.error("Превышено время ожидания ответа от OpenAI API")
            return "Превышено время ожидания ответа от LLM. Пожалуйста, попробуйте еще раз."
        except Exception as e:
            logger.error(f"Ошибка при генерации ответа LLM: {e}")
            return f"Произошла ошибка при генерации ответа: {str(e)}"
    
    def _build_context(self, search_results: List[Dict[str, Any]]) -> str:
        """
        Формирует контекст из результатов поиска для передачи в LLM.
        """
        context_parts = []
        
        for i, result in enumerate(search_results, 1):
            product_id = result.get("product_id")
            product_name = result.get("product_name", f"Документ {i}")
            similarity = result.get("similarity", 0)
            text = result.get("text", "") or result.get("text_preview", "")
            
            # Логируем информацию о документе
            logger.info(f"Документ #{i}: '{product_name}' (ID: {product_id}, сходство: {similarity:.4f})")
            
            # Добавляем информацию о документе в контекст
            document_header = f"=== ДОКУМЕНТ {i}: {product_name} ===\n"
            document_content = f"{text}\n"
            
            context_parts.append(document_header + document_content)
        
        return "\n".join(context_parts)
    
    def _build_user_prompt(self, query: str, context: str) -> str:
        """
        Формирует пользовательский промпт для LLM.
        """
        return USER_PROMPT.format(context=context, query=query)
    
    async def close(self):
        """Закрывает соединение с OpenAI API."""
        if self.client:
            await self.client.close()
