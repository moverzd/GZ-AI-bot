from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import datetime
import logging

from src.handlers.states import AddFiles
from src.database.models import Product, ProductFile
from src.services.product_service import ProductService
from src.keyboards.admin import get_admin_main_menu_keyboard
from src.core.utils import esc

logger = logging.getLogger(__name__)

router = Router()

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø—ã —Ñ–∞–π–ª–æ–≤ –∏ –∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
DOCUMENT_TYPES = {
    'application/pdf': 'pdf',
    'application/msword': 'word', 
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'word',
    'application/vnd.ms-excel': 'excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'excel',
    'application/vnd.ms-powerpoint': 'presentation',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'presentation',
    'application/zip': 'archive',
    'application/x-rar-compressed': 'archive',
    'application/x-7z-compressed': 'archive',
}

MEDIA_TYPES = {
    'image/jpeg': 'image',
    'image/png': 'image',
    'image/gif': 'image',
    'image/webp': 'image',
    'video/mp4': 'video',
    'video/avi': 'video',
    'video/mov': 'video',
    'video/wmv': 'video',
    'video/webm': 'video',
}

def get_file_kind(mime_type: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø —Ñ–∞–π–ª–∞ –ø–æ MIME —Ç–∏–ø—É"""
    if mime_type in DOCUMENT_TYPES:
        return DOCUMENT_TYPES[mime_type]
    elif mime_type in MEDIA_TYPES:
        return MEDIA_TYPES[mime_type]
    else:
        return 'other'

@router.callback_query(lambda c: c.data == 'admin:add_files')
async def admin_add_files_callback(callback: types.CallbackQuery, state: FSMContext, is_admin: bool = False):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ '–î–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª—ã' –∏–∑ –∞–¥–º–∏–Ω—Å–∫–æ–≥–æ –º–µ–Ω—é"""
    if not is_admin:
        await callback.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞", show_alert=True)
        return
    
    await state.set_state(AddFiles.waiting_product_id)
    if callback.message and isinstance(callback.message, types.Message):
        try:
            await callback.message.edit_text(
                "<b>‚ûïüìé –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∫ –ø—Ä–æ–¥—É–∫—Ç—É</b>\n\n"
                "–í–≤–µ–¥–∏—Ç–µ ID –ø—Ä–æ–¥—É–∫—Ç–∞, –∫ –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª—ã:\n"
                "üí° <i>ID –ø—Ä–æ–¥—É–∫—Ç–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ –∫–∞—Ä—Ç–æ—á–∫–µ –ø—Ä–æ–¥—É–∫—Ç–∞ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö –ø–æ–∏—Å–∫–∞</i>",
                parse_mode="HTML",
                reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[
                    types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é", callback_data="admin:menu")
                ]])
            )
        except Exception:
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–µ—Ç—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞), –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
            await callback.answer()
            await callback.message.answer(
                "<b>‚ûïüìé –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∫ –ø—Ä–æ–¥—É–∫—Ç—É</b>\n\n"
                "–í–≤–µ–¥–∏—Ç–µ ID –ø—Ä–æ–¥—É–∫—Ç–∞, –∫ –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª—ã:\n"
                "üí° <i>ID –ø—Ä–æ–¥—É–∫—Ç–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤ –∫–∞—Ä—Ç–æ—á–∫–µ –ø—Ä–æ–¥—É–∫—Ç–∞ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö –ø–æ–∏—Å–∫–∞</i>",
                parse_mode="HTML",
                reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[
                    types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é", callback_data="admin:menu")
                ]])
            )
            return
    await callback.answer()

@router.message(AddFiles.waiting_product_id)
async def process_product_id_for_files(message: types.Message, state: FSMContext, session: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ ID –ø—Ä–æ–¥—É–∫—Ç–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤"""
    if not message.text:
        await message.answer(
            "‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[
                types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é", callback_data="admin:menu")
            ]])
        )
        return
        
    try:
        product_id = int(message.text.strip())
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞
        product_service = ProductService(session)
        product = await product_service.get_product_by_id(product_id)
        
        if not product:
            await message.answer(
                "‚ùå –ü—Ä–æ–¥—É–∫—Ç —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω.\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /admin –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é."
            )
            return
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø—Ä–æ–¥—É–∫—Ç–∞ –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –æ–∂–∏–¥–∞–Ω–∏—é —Ñ–∞–π–ª–∞
        await state.update_data(product_id=product_id, product_name=product['name'])
        await state.set_state(AddFiles.waiting_file)
        
        await message.answer(
            f"<b>–ü—Ä–æ–¥—É–∫—Ç –Ω–∞–π–¥–µ–Ω:</b> {esc(product['name'])}\n\n"
            "–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫ —ç—Ç–æ–º—É –ø—Ä–æ–¥—É–∫—Ç—É.\n\n"
            "<b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:</b>\n"
            "<b>–î–æ–∫—É–º–µ–Ω—Ç—ã:</b> PDF, Word, Excel, PowerPoint, –∞—Ä—Ö–∏–≤—ã\n"
            "<b>–ú–µ–¥–∏–∞:</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (JPG, PNG, GIF, WebP), –≤–∏–¥–µ–æ (MP4, AVI, MOV, WMV, WebM)\n\n"
            "–ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /admin –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é.",
            parse_mode="HTML"
        )
        
    except ValueError:
        await message.answer(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID –ø—Ä–æ–¥—É–∫—Ç–∞. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.\n\n"
            "–ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /admin –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é."
        )

@router.message(AddFiles.waiting_file, F.document)
async def process_document_file(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞"""
    document = message.document
    if not document:
        return
    
    file_size_mb = (document.file_size or 0) / 1024 / 1024
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
    await state.update_data(
        file_id=document.file_id,
        file_size=document.file_size,
        mime_type=document.mime_type,
        original_filename=document.file_name,
        file_type='document'
    )
    
    await state.set_state(AddFiles.waiting_title)
    
    await message.answer(
        f"<b>–î–æ–∫—É–º–µ–Ω—Ç –ø–æ–ª—É—á–µ–Ω:</b> {esc(document.file_name or '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}\n"
        f"<b>–†–∞–∑–º–µ—Ä:</b> {file_size_mb:.2f} –ú–ë\n\n"
        "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:",
        parse_mode="HTML"
    )

@router.message(AddFiles.waiting_file, F.photo)
async def process_photo_file(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    if not message.photo:
        return
        
    photo = message.photo[-1]  # –ë–µ—Ä—ë–º —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
    file_size_mb = (photo.file_size or 0) / 1024 / 1024
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
    await state.update_data(
        file_id=photo.file_id,
        file_size=photo.file_size,
        mime_type='image/jpeg',  # Telegram –≤—Å–µ–≥–¥–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –≤ JPEG
        original_filename=None,
        file_type='media'
    )
    
    await state.set_state(AddFiles.waiting_title)
    
    await message.answer(
        f"<b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ</b>\n"
        f"<b>–†–∞–∑–º–µ—Ä:</b> {file_size_mb:.2f} –ú–ë\n\n"
        "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:",
        parse_mode="HTML"
    )

@router.message(AddFiles.waiting_file, F.video)
async def process_video_file(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –≤–∏–¥–µ–æ"""
    video = message.video
    if not video:
        return
    
    file_size_mb = (video.file_size or 0) / 1024 / 1024
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
    await state.update_data(
        file_id=video.file_id,
        file_size=video.file_size,
        mime_type=video.mime_type,
        original_filename=video.file_name,
        file_type='media'
    )
    
    await state.set_state(AddFiles.waiting_title)
    
    await message.answer(
        f"<b>–í–∏–¥–µ–æ –ø–æ–ª—É—á–µ–Ω–æ:</b> {esc(video.file_name or '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}\n"
        f"<b>–†–∞–∑–º–µ—Ä:</b> {file_size_mb:.2f} –ú–ë\n"
        f" <b>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:</b> {video.duration or 0} —Å–µ–∫\n\n"
        "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:",
        parse_mode="HTML"
    )

@router.message(AddFiles.waiting_file)
async def process_unsupported_file(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞"""
    await message.answer(
        "‚ùå <b>–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞</b>\n\n"
        "<b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:</b>\n"
        "<b>–î–æ–∫—É–º–µ–Ω—Ç—ã:</b> PDF, Word, Excel, PowerPoint, –∞—Ä—Ö–∏–≤—ã\n"
        "<b>–ú–µ–¥–∏–∞:</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (JPG, PNG, GIF, WebP), –≤–∏–¥–µ–æ (MP4, AVI, MOV, WMV, WebM)\n\n"
        "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –¥—Ä—É–≥–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /admin –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é.",
        parse_mode="HTML"
    )

@router.message(AddFiles.waiting_title)
async def process_file_title(message: types.Message, state: FSMContext, session: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î"""
    if not message.text:
        await message.answer(
            "‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑:",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[
                types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é", callback_data="admin:menu")
            ]])
        )
        return
        
    title = message.text.strip()
    
    if not title:
        await message.answer(
            "‚ùå –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑:"
        )
        return
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    
    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ñ–∞–π–ª–∞ –ø–æ MIME —Ç–∏–ø—É
        file_kind = get_file_kind(data.get('mime_type', ''))
        
        # –ü–æ–ª—É—á–∞–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_id = message.from_user.id if message.from_user else None
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Ä–≤–∏—Å –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞
        from src.services.file_service import FileService
        file_service = FileService(session)
        
        # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ –ª–æ–∫–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–∏—Å
        is_document = file_kind in ['document', 'pdf', 'word', 'excel', 'presentation', 'archive', 'other']
        new_file = await file_service.download_and_store_file(
            file_id=data['file_id'],
            product_id=data['product_id'],
            is_document=is_document,
            title=title,
            file_kind=file_kind,
            file_size=data.get('file_size'),
            mime_type=data.get('mime_type'),
            original_filename=data.get('original_filename')
        )
        
        # –ü–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é –ø—Ä–æ–¥—É–∫—Ç–∞
        try:
            from src.services.auto_chunking_service import AutoChunkingService
            auto_chunking = AutoChunkingService()
            await auto_chunking.reindex_product(data['product_id'], data['product_name'], session)
            logger.info(f"–ü—Ä–æ–¥—É–∫—Ç {data['product_id']} –ø–µ—Ä–µ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞")
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç {data['product_id']} –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}")
            # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, —Ç–∞–∫ –∫–∞–∫ —Ñ–∞–π–ª —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω
        
        await message.answer(
            f"<b>‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
            f"<b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> {esc(title)}\n"
            f"<b>–ü—Ä–æ–¥—É–∫—Ç:</b> {esc(data['product_name'])}\n"
            f"<b>–¢–∏–ø:</b> {file_kind}\n\n"
            "–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë —Ñ–∞–π–ª—ã –∫ —ç—Ç–æ–º—É –ø—Ä–æ–¥—É–∫—Ç—É?",
            parse_mode="HTML",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(
                    text="üìé –î–æ–±–∞–≤–∏—Ç—å –µ—â—ë —Ñ–∞–π–ª", 
                    callback_data=f"add_more_files:{data['product_id']}"
                )],
                [types.InlineKeyboardButton(
                    text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é", 
                    callback_data="admin:menu"
                )]
            ])
        )
        
        # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        await state.clear()
        
    except Exception as e:
        await message.answer(
            f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {str(e)}\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[
                        types.InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é", callback_data="admin:menu")
                    ]])
        )
        await state.clear()

@router.callback_query(lambda c: c.data and c.data.startswith('add_more_files:'))
async def add_more_files_callback(callback: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –µ—â—ë –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∫ —Ç–æ–º—É –∂–µ –ø—Ä–æ–¥—É–∫—Ç—É"""
    if not callback.data:
        return
        
    product_id = int(callback.data.split(':')[1])
    
    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–¥—É–∫—Ç–µ
    product_service = ProductService(session)
    product = await product_service.get_product_by_id(product_id)
    
    if not product:
        await callback.answer("–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return
    
    await state.update_data(product_id=product_id, product_name=product['name'])
    await state.set_state(AddFiles.waiting_file)
    
    if callback.message and isinstance(callback.message, types.Message):
        try:
            await callback.message.edit_text(
                f"<b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∫ –ø—Ä–æ–¥—É–∫—Ç—É:</b> {esc(product['name'])}\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫ —ç—Ç–æ–º—É –ø—Ä–æ–¥—É–∫—Ç—É.\n\n"
                "<b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:</b>\n"
                "<b>–î–æ–∫—É–º–µ–Ω—Ç—ã:</b> PDF, Word, Excel, PowerPoint, –∞—Ä—Ö–∏–≤—ã\n"
                "<b>–ú–µ–¥–∏–∞:</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (JPG, PNG, GIF, WebP), –≤–∏–¥–µ–æ (MP4, AVI, MOV, WMV, WebM)",
                parse_mode="HTML"
            )
        except Exception:
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–µ—Ç—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞), –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
            await callback.answer()
            await callback.message.answer(
                f"<b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∫ –ø—Ä–æ–¥—É–∫—Ç—É:</b> {esc(product['name'])}\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫ —ç—Ç–æ–º—É –ø—Ä–æ–¥—É–∫—Ç—É.\n\n"
                "<b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:</b>\n"
                "<b>–î–æ–∫—É–º–µ–Ω—Ç—ã:</b> PDF, Word, Excel, PowerPoint, –∞—Ä—Ö–∏–≤—ã\n"
                "<b>–ú–µ–¥–∏–∞:</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (JPG, PNG, GIF, WebP), –≤–∏–¥–µ–æ (MP4, AVI, MOV, WMV, WebM)",
                parse_mode="HTML"
            )
            return
    await callback.answer()

@router.callback_query(lambda c: c.data == 'admin:menu')
async def return_to_admin_menu(callback: types.CallbackQuery):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω—Å–∫–æ–µ –º–µ–Ω—é"""
    if callback.message and isinstance(callback.message, types.Message):
        try:
            await callback.message.edit_text(
                "<b>üõ†Ô∏è –ü–∞–Ω–µ–ª—å –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n"
                "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                parse_mode="HTML",
                reply_markup=get_admin_main_menu_keyboard()
            )
        except Exception:
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–µ—Ç—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞), –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
            await callback.answer()
            await callback.message.answer(
                "<b>üõ†Ô∏è –ü–∞–Ω–µ–ª—å –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n"
                "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                parse_mode="HTML",
                reply_markup=get_admin_main_menu_keyboard()
            )
            return
    await callback.answer()
